'The 6502 Assembler and Interpreter Project Assembler (T6AIP-ASM)
'By: NateDogg1232

OPTION DEFINT:OPTION STRICT

'Required functions

'Set byte in INT
DEF SETBYTE(INP,BYTE,POS)
 BYTE=BYTE AND &HFF
 INP=INP AND (NOT (&HFF<<(POS*8)))
 RETURN INP OR (BYTE<<(POS*8))
END
'Read byte in INT
'DEF READBYTE(INP,POS)
' RETURN (INP AND (&HFF<<(POS*8)))>>(POS*8)
'END

'DEF SETBYTEINARRAYSLOW ARR,BYTE,POS
' VAR MASK=NOT (&HFF<<(POS*8))
' VAR IDX=FLOOR(POS/4)
' 'Clear out that byte
' ARR[IDX]=ARR[IDX] AND MASK
' 'Set the new byte
' VAR NEWBYTE=((BYTE AND &HFF)<<(POS*8))
' ARR[IDX]=ARR[IDX] OR NEWBYTE
'END

DEF GETBYTEARRAY(ARR,POS)
 VAR POSMOVE=(POS*8)
 RETURN ((ARR[FLOOR(POS/4)+1] AND (&HFF<<POSMOVE))>>POSMOVE) AND &HFF
END

DEF SETBYTEARRAY ARR,BYTE,POS
 VAR IDX=FLOOR(POS/4)+1
 'Set the new byte
 ARR[IDX]=(ARR[IDX] AND NOT (&HFF<<(POS*8))) OR ((BYTE AND &HFF)<<(POS*8))
END

DEF PUSHBYTEARRAY ARR,BYTE
 IF ARR[0]>3 THEN
  ARR[0]=1
  PUSH ARR, BYTE AND &HFF
  RETURN
 ENDIF
 ARR[LEN(ARR)-1]=SETBYTE(ARR[LEN(ARR)-1],BYTE,ARR[0])
 INC ARR[0],1
END
DEF LENBYTEARRAY(ARR)
 RETURN ((LEN(ARR)-2)*4)+ARR[0]
END

DEF PUSHWORDARRAY ARR,WORD
 PUSHBYTEARRAY ARR,(WORD AND &HFF00)>>8
 PUSHBYTEARRAY ARR,WORD AND &HFF
END
 
 

DEF PREPAREBYTEARRAY ARR, SIZE
 VAR I
 aDel ARR
 'We use this as an index
 PUSH ARR,0
 'Then we add the size of the array
 FOR I=0 TO FLOOR(SIZE/4)
  PUSH ARR,0
 NEXT I
END

DEF aDel A
 'Thanks, ShionAmasato
 IF LEN(A) THEN
  VAR V$="N"+"$"*((A[0]>0)>2),N,N$
  WHILE LEN(A)
   VAR(V$)=POP(A)
  WEND
 ENDIF
END



'DEF REPLACESLOW$(INP$,SEARCH$,REP$)
' VAR IDX
' 'We leave the source string alone
' VAR RET$=INP$
' VAR TMP1$,TMP2$,TMP3$
' WHILE TRUE
'  IDX=INSTR(RET$,SEARCH$)
'  IF IDX<0 THEN BREAK
'  TMP1$=LEFT$(RET$,IDX)
'  TMP2$=RIGHT$(RET$,LEN(RET$)-(IDX+LEN(SEARCH$)))
'  RET$=TMP1$+REP$+TMP2$
' WEND
' RETURN RET$
'END
DEF REPLACE$(INP$,SEARCH$,REP$)
 VAR IDX
 VAR RET$=INP$
 @LOOP
  IDX=INSTR(RET$,SEARCH$)
  IF IDX<0 THEN @SKIP
  RET$=LEFT$(RET$,IDX)+REP$+RIGHT$(RET$,LEN(RET$)-(IDX+LEN(SEARCH$)))
 GOTO @LOOP
 @SKIP
 RETURN RET$
END
DEF TOUPPER$(T$)
 VAR I
 FOR I=0 TO LEN(T$)-1
  IF ASC(T$[I])>64 AND ASC(T$[I])>91 THEN
   T$=SUBST$(T$,I,1,CHR$(ASC(T$[I])-32))
  ENDIF
 NEXT
 RETURN T$
END

DEF WARN STRING$
 COLOR #TOLIVE
 PRINT "[WARN]: ";
 COLOR #TWHITE
 PRINT STRING$
END
DEF INFO STRING$
 COLOR #TBLUE
 PRINT "[INFO]: ";
 COLOR #TWHITE
 PRINT STRING$
END
DEF ERR STRING$
 COLOR #TRED
 PRINT "[ERROR]: ";
 COLOR #TWHITE
 PRINT STRING$
END

'Split string into array using delimiter
DEF STRINGSPLIT$(STRING$,DELIM$)
 DIM R$[0],THS,NXT
 WHILE #TRUE
  NXT=INSTR(THS,STRING$,DELIM$)
  IF NXT<0 THEN BREAK
  PUSH R$,MID$(STRING$,THS,NXT-THS)
  THS=NXT+1
 WEND
 PUSH R$,RIGHT$(STRING$,LEN(STRING$)-THS)
 RETURN R$
END

'Taken from Lowerdash
DEF TRIM$(S$)
  VAR T$ = " "
  WHILE LEFT$(S$,1) == T$
    S$ = RIGHT$(S$,LEN(S$)-1)
  WEND
  WHILE RIGHT$(S$,1) == T$
    S$ = LEFT$(S$,LEN(S$)-1)
  WEND
  RETURN S$
END


DEF PARSEARGBYTE(S$)
 VAR IDX=INSTR(S$,"$")
 VAR TMP$
 IF IDX<=0 THEN
  IDX=INSTR(S$,"#")
 ENDIF
 IF IDX>=0 THEN
  TMP$=RIGHT$(S$,LEN(S$)-(IDX+1))
  RETURN VAL("&H"+TMP$)
 ENDIF
END

DEF GETARGVALUE(S$)
 VAR IDX=INSTR(S$,"$")
 'Address given
 IF IDX>=0 THEN
  IDX=INSTR(S$,"($")
  IF IDX>=0 THEN
   RETURN VAL("&H"+MID$(S$,IDX+2,2))
  ENDIF
  IDX=INSTR(S$,"$")
  IF (LEN(S$)-1)-IDX==2 THEN
   RETURN VAL("&H"+MID$(S$,IDX+1,2))
  ENDIF
  IF (LEN(S$)-1)-IDX==4 THEN
   IF RIGHT$(S$,2)==",X" THEN
    RETURN VAL("&H"+MID$(S$,IDX+1,2))
   ENDIF
   IF RIGHT$(S$,2)==",Y" THEN
    RETURN VAL("&H"+MID$(S$,IDX+1,2))
   ENDIF
   RETURN VAL("&H"+MID$(S$,IDX+1,4))
  ENDIF
  IF (LEN(S$)-1)-IDX==6 THEN
   IF RIGHT$(S$,2)==",X" THEN
    RETURN VAL("&H"+MID$(S$,IDX+1,4))
   ENDIF
   IF RIGHT$(S$,2)==",Y" THEN
    RETURN VAL("&H"+MID$(S$,IDX+1,4))
   ENDIF
  ENDIF
 ENDIF
 IDX=INSTR(S$,"#")
 IF IDX>=0 THEN
  RETURN VAL("&H"+MID$(S$,IDX+1,2))
 ENDIF 
END

'0:Accumulator
'1:$Absolute
'2:$Absolute, X
'3:$Absolute, Y
'4:#Immediate
'5:($Indirect)
'6:($Indirect,X)
'7:($Indirect),Y
'8:$ZeroPage/$Relative
'9:$Zeropage, X
'10:$Zeropage, Y

'255:Error
DEF GETARGTYPE(S$)
 IF S$=="A" THEN
  'Accumulator
  RETURN 0
 ENDIF
 VAR IDX=INSTR(S$,"$")
 'Address given
 IF IDX>=0 THEN
  IDX=INSTR(S$,"($")
  IF IDX>=0 THEN
   IF RIGHT$(S$,3)=="),Y" THEN
    '(Indirect),Y
    RETURN 7
   ENDIF
   IF RIGHT$(S$,3)==",X)" THEN
    '(Indirect,X)
    RETURN 6
   ENDIF
   IF RIGHT$(S$,1)==")" THEN
    RETURN 5
   ENDIF
  ENDIF
  IDX=INSTR(S$,"$")
  IF (LEN(S$)-1)-IDX==2 THEN
   'Zero page
   RETURN 8
  ENDIF
  IF (LEN(S$)-1)-IDX==4 THEN
   IF RIGHT$(S$,2)==",X" THEN
    'Zero page, X
    RETURN 9
   ENDIF
   IF RIGHT$(S$,2)==",Y" THEN
    'Zero page, Y
    RETURN 10
   ENDIF
   'Absolute
   RETURN 1
  ENDIF
  IF (LEN(S$)-1)-IDX==6 THEN
   IF RIGHT$(S$,2)==",X" THEN
    'Absolute,X
    RETURN 2
   ENDIF
   IF RIGHT$(S$,2)==",Y" THEN
    'Absolute,Y
    RETURN 3
   ENDIF
  ENDIF
  'Error
  RETURN 255
 ENDIF
 IDX=INSTR(S$,"#")
 IF IDX>=0 THEN
  'Immediate
  RETURN 4
 ENDIF 
 RETURN 255
END

@INIT

ACLS
INFO "Loading"

'Index variables
VAR I,J,H

DIM PROG[0]

DIM HEADER[0]

VAR VER$="0.1"

'We use this as a do-fix table
DIM NEXTPASS$[0]
DIM NEXTPASS[0]

'Defined token
DIM DEFINETOK$[0]
'Defined value
DIM DEFINEVAL$[0]

VAR INFILE$=""
VAR OUTFILE$=""

DIM PROG$[0]

DIM TMPARR$[0]
DIM TMPARR[0]

VAR TMP$=""
VAR TMP=0
VAR TRASH$=""

VAR FILE$=""

VAR I$="",J$=""

VAR CURRLINE


DEF PRINTPROG
 FOR I=0 TO LEN(PROG)-1
  PRINT FORMAT$("%08X",PROG[I])
 NEXT I
END

PRINT "Welcome to T6AIP-ASM"

@CMD


WHILE TRUE
 PRINT "-";
 LINPUT I$
 I$=TRIM$(I$)
 J$=LEFT$(I$,1)
 IF J$=="I" THEN
  'Set the input file
  INFILE$=RIGHT$(I$,LEN(I$)-1)
  INFILE$=TRIM$(INFILE$)
  INFO "Input file set to "+INFILE$
  IF !CHKFILE("TXT:"+INFILE$) THEN
   WARN "File does not exist!"
  ENDIF
 ELSEIF J$=="O" THEN
  'Set the output file
  OUTFILE$=RIGHT$(I$,LEN(I$)-1)
  OUTFILE$=TRIM$(OUTFILE$)
  INFO "Output file set to "+OUTFILE$
 ELSEIF J$=="H" THEN
  ? "- `I (File)` - Sets input file
  ? "- `O (File)` - Sets output file
  ? "- `A` - Assemble
  ? "- `H` - Help
  ? "- `Q` - Quit
 ELSEIF J$=="A" THEN
  BREAK
 ELSEIF J$=="Q" THEN
  END
 ELSE
  ERR "Incorrect command"
 ENDIF
WEND

@PREPAREPROG

WARN "Pass 0: Preparing code"


LOAD "TXT:"+INFILE$, FALSE OUT FILE$



TMP$=""
'Seperate the program into lines
PROG$=STRINGSPLIT$(FILE$, CHR$(10))

'Trim each line
FOR I=0 TO LEN(PROG$)-1
 PROG$[I]=TRIM$(PROG$[I])
NEXT I

WARN "Pass 0.5: Processing pre-pass directives"

FOR I=0 TO LEN(PROG$)-1
 'Skip blank lines and comments
 IF PROG$[I]=="" THEN CONTINUE
 IF LEFT$(PROG$[I],1)==";" THEN CONTINUE
 
 TMPARR$=STRINGSPLIT$(PROG$[I]," ")
 'Check for any pre-pass directives
 IF LEFT$(TMPARR$[0],1)=="." THEN
  'Now we know that the intention is a
  'directive
  IF TOUPPER$(TMPARR$[0])==".DEFINE" THEN
   PUSH DEFINETOK$, TMPARR$[1]
   PUSH DEFINEVAL$, TMPARR$[2]
  ENDIF
  
 ENDIF
NEXT I

CURRLINE=0

PREPAREBYTEARRAY PROG,0

WARN "Pass 1: Main pass"

@PASS1

IF CURRLINE>=LEN(PROG$) THEN @FINISHPASS1

'Check for a blank line
IF PROG$[CURRLINE]=="" THEN
 INC CURRLINE,1
 GOTO @PASS1
ENDIF
'Check for comments
IF LEFT$(PROG$[CURRLINE],1)==";" THEN
 INC CURRLINE,1
 GOTO @PASS1
ENDIF

TMPARR$=STRINGSPLIT$(PROG$[CURRLINE],";") 'Remove all comments

'We replace any instance of any defined
'tokens with their values
FOR I=0 TO LEN(DEFINETOK$)-1
 TMPARR$[0]=REPLACE$(TMPARR$[0],DEFINETOK$[I],DEFINEVAL$[I])
NEXT


TMPARR$=STRINGSPLIT$(TRIM$(TMPARR$[0]), " ")

TMPARR$[0]=TOUPPER$(TMPARR$[0])

INFO TMPARR$[0]

'We check the directives
'.define
IF TMPARR$[0]==".DEFINE" THEN
 INFO "Skipping .define directive"
 'We already did this, so we skip it
 INC CURRLINE,1
 GOTO @PASS1
ENDIF

'.db byte
IF TMPARR$[0]==".DB" THEN
 FOR I=1 TO LEN(TMPARR$)-1
  PUSHBYTEARRAY PROG,PARSEARGBYTE(TMPARR$[I])
 NEXT I
 INC CURRLINE,1
 GOTO @PASS1
ENDIF

'.dw word
IF TMPARR$[0]==".DW" THEN
 FOR I=1 TO LEN(TMPARR$)-1
  PUSHWORDARRAY PROG,PARSEARGBYTE(TMPARR$[I])
 NEXT I
 INC CURRLINE,1
 GOTO @PASS1
ENDIF

'.incbin
IF TMPARR$[0]==".INCBIN" THEN
 IF !CHKFILE("DAT:"+TMPARR$[1]) THEN
  ERR "("+STR$(CURRLINE)+":"+PROG$[CURRLINE]+") File does not exist!: '"+TMPARR$[1]+"'"
 ENDIF
 LOAD "DAT:"+TMPARR$[1], TMPARR, FALSE
 'Load bytes out of it
 FOR I=0 TO LENBYTEARRAY(TMPARR)-1
  PUSHBYTEARRAY PROG,GETBYTEARRAY(TMPARR,I)
 NEXT I
ENDIF


'ADC
'Immediate: 69 (2b)
'Zeropage: 65 (2b)
'Zeropage, X: 75 (2b)
'Absolute: 6D (3b)
'Absolute, X: 7D (3b)
'Absolute, Y: 79 (3b)
'(Indirect,X): 61 (2b)
'(Indirect),Y: 71 (2b)
IF TMPARR$[0]=="ADC" THEN
 'Immediate
 IF GETARGTYPE(TMPARR$[1])==4 THEN
  PUSHBYTEARRAY PROG, &H69
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 'Zeropage
 IF GETARGTYPE(TMPARR$[1])==8 THEN
  PUSHBYTEARRAY PROG, &H65
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 'Zeropage,X
 IF GETARGTYPE(TMPARR$[1])==9 THEN
  PUSHBYTEARRAY PROG, &H75
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 'Absolute
 IF GETARGTYPE(TMPARR$[1])==1 THEN
  PUSHBYTEARRAY PROG, &H6D
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 'Absolute,X
 IF GETARGTYPE(TMPARR$[1])==2 THEN
  PUSHBYTEARRAY PROG, &H7D
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 'Absolute,Y
 IF GETARGTYPE(TMPARR$[1])==3 THEN
  PUSHBYTEARRAY PROG, &H79
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 '(Indirect,X)
 IF GETARGTYPE(TMPARR$[1])==6 THEN
  PUSHBYTEARRAY PROG, &H61
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
 '(Indirect),Y
 IF GETARGTYPE(TMPARR$[1])==7 THEN
  PUSHBYTEARRAY PROG, &H71
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 ENDIF
ENDIF

'AND
'Immediate: 29 (2b)
'Zeropage: 25 (2b)
'Zeropage, X: 35 (2b)
'Absolute: 2D (3b)
'Absolute, X: 3D (3b)
'Absolute, Y: 39 (3b)
'(Indirect,X): 21 (2b)
'(Indirect),Y: 31 (2b)
IF TMPARR$[0]=="AND" THEN
 'Immediate
 ELSEIF GETARGTYPE(TMPARR$[1])==4 THEN
  PUSHBYTEARRAY PROG, &H29
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Zeropage
 ELSEIF GETARGTYPE(TMPARR$[1])==8 THEN
  PUSHBYTEARRAY PROG, &H25
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Zeropage,X
 ELSEIF GETARGTYPE(TMPARR$[1])==9 THEN
  PUSHBYTEARRAY PROG, &H35
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Absolute
 ELSEIF GETARGTYPE(TMPARR$[1])==1 THEN
  PUSHBYTEARRAY PROG, &H2D
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Absolute,X
 ELSEIF GETARGTYPE(TMPARR$[1])==2 THEN
  PUSHBYTEARRAY PROG, &H3D
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Absolute,Y
 ELSEIF GETARGTYPE(TMPARR$[1])==3 THEN
  PUSHBYTEARRAY PROG, &H39
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 '(Indirect,X)
 ELSEIF GETARGTYPE(TMPARR$[1])==6 THEN
  PUSHBYTEARRAY PROG, &H21
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 '(Indirect),Y
 ELSEIF GETARGTYPE(TMPARR$[1])==7 THEN
  PUSHBYTEARRAY PROG, &H31
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Invalid argument type
 ELSE
  ERR "("+STR$(CURRLINE)+":"+PROG$[CURRLINE]+") Invalid argument type!"
 ENDIF
ENDIF

'ASL
'Accumulator: 0A (2b)
'Zeropage: 06 (2b)
'Zeropage, X: 16 (2b)
'Absolute: 2E (3b)
'Absolute, X: 1E (3b)
IF TMPARR$[0]=="AND" THEN
 'Accumulator
 IF GETARGTYPE(TMPARR$[1])==0 THEN
  PUSHBYTEARRAY PROG, &H0A
 'Zeropage
 ELSEIF GETARGTYPE(TMPARR$[1])==8 THEN
  PUSHBYTEARRAY PROG, &H06
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Zeropage,X
 ELSEIF GETARGTYPE(TMPARR$[1])==9 THEN
  PUSHBYTEARRAY PROG, &H16
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Absolute
 ELSEIF GETARGTYPE(TMPARR$[1])==1 THEN
  PUSHBYTEARRAY PROG, &H2E
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Absolute,X
 ELSEIF GETARGTYPE(TMPARR$[1])==2 THEN
  PUSHBYTEARRAY PROG, &H1E
  PUSHWORDARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Invalid argument type
 ELSE
  ERR "("+STR$(CURRLINE)+":"+PROG$[CURRLINE]+") Invalid argument type!"
 ENDIF
ENDIF

'BCC
'Relative: 90 (2b)
'Do-fix
IF TMPARR$[0]=="BCC" THEN
 'Relative
 EIF GETARGTYPE(TMPARR$[1])==8 THEN
  PUSHBYTEARRAY PROG, &H90
  PUSHBYTEARRAY PROG, GETARGVALUE(TMPARR$[1])
 'Invalid argument type
 ELSE
  ERR "("+STR$(CURRLINE)+":"+PROG$[CURRLINE]+") Invalid argument type!"
 ENDIF
ENDIF

@FINISHPASS1
PRINTPROG

